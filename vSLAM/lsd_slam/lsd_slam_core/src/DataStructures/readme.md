# lsd_core  数据结构 内存管理类
## Frame 帧类 详情
    * 每张图像创建 5层的图像金字塔  每一层的尺度 变为上一层的1/2
    * 图像的 内参数 也上上一层的 1/2
    * 内参数求逆得到 内参数逆矩阵
    * 
### 一、图像金字塔构建方法为 ：
    * 上一层 的 四个像素的值的平均值合并成一个像素为下一层的像素
    * 
    * 	int wh = width*height;// 当前层 像素总数
    *	const float* s;
    *	for(int y=0; y<wh; y += width*2)// 隔行
    *	{
    *		for(int x=0; x<width; x+= 2)// 隔列下采样
    *		{
    *			s = source + x + y;// 上一层 像素对应位置
    *			*dest = (s[0] +
    *					s[1] +
    *					s[width] +
    *					s[1+width]) * 0.25f;// 四个像素的值的平均值合并成一个
    *			dest++;
    *		}
    *	}
    * 
### 二、梯度金字塔构建方法（四个值  dx ， dy， i， null)
    * 使用同一层的 图像  左右像素求得x方向梯度  上下求得 方向梯度 
    *           *(img_pt-width)
    *  val_m1  *(img_pt)   val_p1
    *           *(img_pt+width)
    * 1.  (val_p1 - val_m1)/2    = x 方向梯度
    * 2.  0.5f*(*(img_pt+width) - *(img_pt-width)) = y方向梯度
    * 3.  val_00 = *(img_pt)   当前 点像素值
    * 4. 第四维度 没有存储数据    gradxyii_pt  Eigen::Vector4f
    *
    * 
### 三、临近最大合成梯度 值 地图构建 一个合成梯度值
    *  创建 梯度图内 临近四点中梯度最大值 的 最大值梯度 图 ， 并记录梯度值较大的可以映射 成 地图点的数量
    * 在梯度图中 求去合成梯度 g=sqrt(gx^2+gy^2)  ，求的 上中下 三个梯度值中的最大值，形成临时梯度最大值图
    * 在临时梯度最大值图 中求 的  左中右 三个梯度值中的最大值，形成最后的 最大梯度值地图
    *  并记录 最大梯度大小超过阈值的点 可以映射成地图点  
    * 
### 四、构建 第0层 逆深度均值图 和方差图
    * 1. 使用 真实 深度值  取反得到逆深度值，方差初始为一个设定值
    * 2. 没有真实值是，也可以使用高斯分布均值初始化 逆深度均值图 和方差图
    * 
### 五、高层逆深度均值金字塔图 和逆深度方差金字塔图的构建
    * 
    *  根据逆深度 构建  逆深度均值图 方差图(高斯分布)  金字塔
    *       current   -----> 右边一个
    *       下边                下右边       上一层四个位置 
    *  上一层 逆方差和  /  上一层 逆深度均值 (四个位置处) 和  得到深度信息 再 取逆得到 逆深度均值
    *  上一层 逆深度 方差和 取逆得到 本层 逆深度方差 

